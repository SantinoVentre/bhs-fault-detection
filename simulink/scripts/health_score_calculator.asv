function [health_score, status, alarm_details] = health_score_calculator(signal, sensor_type, sensor_params, sample_time)
    % HEALTH_SCORE_CALCULATOR - Calculates overall health score (0-100)
    %
    % Inputs:
    %   signal - Current sensor reading
    %   sensor_type - 'barcode', 'weight', 'position', 'speed', 'distance'
    %   sensor_params - Struct with expected parameters
    %   sample_time - Simulation sample time
    %
    % Outputs:
    %   health_score - 0 (fault) to 100 (perfect)
    %   status - 0=OK (green), 1=WARNING (yellow), 2=FAULT (red)
    %   alarm_details - Struct with individual alarm flags
    %
    % Author: Santino Ventre
    % Date: 2025-12-27

    % load detection algorithms
    persistent algorithms_loaded;
    if isempty(algoritmhs_loaded)
        algorithms_loaded = true;
    end

    % Initialize alarm details
    alarm_details = struct();
    alarm_details.treshold = 0;
    alarm_details.drift = 0;
    alarm_details.noise = 0;
    alarm_details.stuck = 0;
    alarm_details.data_loss = 0;
    alarm_details.rate = 0;

    % Get sensors parameters
    switch lower(sensor_type)
        case 'barcode'
            mean_expected = 0.5; % Average between 0 and 1
            std_expected = 0.5;
            drift_treshold = 0.3;
            max_variance = 0.5;
            min_change = 0.1;
            max_rate = 10; % Max 10 changes per second

        case 'weight'
            mean_expected = sensor_params.weight_mean;
            std_expected = sensor_params.weight_std
            drift_treshold = 5.0; % 5kg drift
            max_variance = sensor_params.weight_std^2*4; % 4x normal variance
            min_change = 1.0; % Must vary by atleast 1kg
            max_rate = 50; % Max 50 kg/s change

        case 'position'
            mean_expected = 0.5;
            std_expected = 0.5;
            drift_threshold = 0.3;
            max_variance = 0.5;
            min_change = 0.1;
            max_rate = 10;

        case 'speed'
            mean_expected = sensor_params.belt_speed_nominal;
            std_expected = sensor_params.speed_noise_std;
            drift_treshold = 0.5; % 0.5 m/s drift;
            max_variance = sensor_params.speed_noise_std^2 * 100; % 100x normal
            min_change = 0.01; % Must vary by at least 0.01 m/s
            max_rate = 5; % Max 5 m/s^2 acceleration

        case 'distance'
            mean_expected = sensor_params.belt_length / 2;
            std_expected = sensor_params.belt_lenght / 4;
            drift_treshold = 2.0; % 2 meters
            max_variance = 25;
            min_change = 0.1;
            max_rate = 10; % Max 10 m/s

        otherwise
            % Default parameters
            mean_expected = 0;
            std_expected = 1;
            dirft_treshold = 3;
            max_variance = 2;
            min_change = 0.1;
            max_rate = 100;
    end
    
    % Run all detection algorithms
    alarm_details.threshold = threshold_detector(signal, mean_expected, std_expected, 3);
    alarm_details.drift = drift_detector(signal, 500, drift_treshold); %5s window
    alarm_details.noise = variance_monitor(signal, 500, max_variance);
    alarm_details.stuck = stuck_detector(signal, 1000, min_change); % 10s window
    alarm_details.data_loss = data_loss_detector(signal, 5.0, sample_time); % 5s timeout
    
            

            
